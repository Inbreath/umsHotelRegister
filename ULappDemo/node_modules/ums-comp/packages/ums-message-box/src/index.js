/**
 * Created by zmw on 2017/7/7.
 */
var defaults = {
    type: null,
    title: null,
    message: null,
    loadingTime: 0,
    loadingTimeFlag: true,
    callback: null,
    inputValue: '',
    radioValue: '',
    radioOpts: null
}

function merge(target){
    for (var i = 1, j = arguments.length; i < j; i++){
        var source = arguments[i]
        for (var prop in source){
            if (source.hasOwnProperty(prop)){
                var value = source[prop]
                value !== undefined && (target[prop] = value)
            }
        }
    }
    return target
}

import messageBox from  './index.vue'
import ums_api from 'ums-api'

var MessageBox,instance = null,initInstance,handler, isNotLoading = false, currentMsg = {},instanceLoop = []
var messageBoxConstructor = Vue.extend(messageBox)

var defaultCallback = function (action) {

    if(currentMsg.callback !== undefined && typeof currentMsg.callback == 'function') {
        if (instance.type == 'promptInput') {
            currentMsg.callback(instance.inputValue, action)
        }else if (instance.type == 'prompRadio'){
            currentMsg.callback(instance.radioValue, action)
        }
    }

    if (action === 'cancel'){
        currentMsg.reject && currentMsg.reject({action})
    }else if (action === 'confirm'){
        let val
        if (instance.type == 'promptInput') {
            val = instance.inputValue
        }else if (instance.type == 'promptRadio'){
            val = instance.radioValue
        }
        currentMsg.resolve && currentMsg.resolve({action,value:val})
    }else {
        currentMsg.resolve && currentMsg.resolve(action)
    }
}

var MessageBox = function (options) {
    if (typeof options === 'string') {
        options = {
            message: arguments[0],
        }
        arguments[1] !== undefined && (options.loadingTime = arguments[1])
        arguments[2] !== undefined && (options.type = arguments[2])
    }
    preventKey()
    initInstance()
    if (isNotLoading === true){
        return new Promise(function (resolve, reject) {
            for (var prop in options) {
                if (options.hasOwnProperty(prop)) {
                    instance[prop] = options[prop]
                }
            }
            currentMsg.resolve = resolve
            currentMsg.reject = reject
            instance.callback = defaultCallback
            instance.isNotLoading = isNotLoading
            Vue.nextTick(function () {
                weex.document.body.appendChild(instance.$el)
            })
        })
    }else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                instance[prop] = options[prop]
            }
        }
        instance.isNotLoading = isNotLoading
        Vue.nextTick(function () {
            weex.document.body.appendChild(instance.$el)
        })
    }
}

initInstance = function () {
    let el = weex.document.createElement('div')
    weex.document.body.appendChild(el)
    instance =  new messageBoxConstructor({
        el
    })
    instanceLoop.push(instance)
}

MessageBox.loading = function (loadingText,loadingTime,options = {}){
    isNotLoading = false
    options.type == undefined && (options.type = 'loading')
    options.message = loadingText
    options.loadingTime =  loadingTime
    return MessageBox(merge(defaults, options))
}

MessageBox.alert = function (title, message, options = {}) {
    isNotLoading = true
    options.type = 'alert'
    title !== undefined && (options.title = title)
    message!== undefined && (options.message = message)
    return MessageBox(merge(defaults, options))
}

MessageBox.confirm = function (title, message, loadingTime, options = {}) {
    isNotLoading = true
    options.type = 'confirm'
    title !== undefined && (options.title = title)
    message !== undefined && (options.message = message)
    loadingTime !== undefined && (options.loadingTime = loadingTime)
    return MessageBox(merge(defaults,options))
}

MessageBox.promptInput = function (title, message, loadingTime, options = {}) {
    isNotLoading = true
    options.type = 'promptInput'
    title !== undefined && (options.title = title)
    message !== undefined && (options.message = message)
    loadingTime !== undefined && (options.loadingTime = loadingTime)
    return MessageBox(merge(defaults,options))
}

MessageBox.promptRadio = function (title, RadioOpts = [], options = {}) {
    isNotLoading = true
    options.type = 'promptRadio'
    title !== undefined && (options.title = title)
    RadioOpts.forEach((cur) => {
        cur.flag = false
    })
    RadioOpts[0].flag = true
    options.radioOpts = RadioOpts
    return MessageBox(merge(defaults, options))
}

function preventKey(){
    if(handler !== null) {
        return
    }
    handler = ums_api.backEvent.initTouchEvent(() => {});
    ['home', 'back', 'menu'].forEach((cur) => {
        handler[cur] = true
    })
}

function restoreKey() {
    if (handler == null) {
        return
    }
    ['home', 'back', 'menu'].forEach((cur) => {
        handler[cur] = false
    })
    handler = null
}

MessageBox.close = function () {
    restoreKey()
    instance = null
    if (instanceLoop.length === 0) {
        return
    }
    while (instanceLoop.length !== 0) {
        let instance = instanceLoop.shift()
        if (instance.$el != null){
            weex.document.body.removeChild(instance.$el)
        }
    }
}

export default MessageBox